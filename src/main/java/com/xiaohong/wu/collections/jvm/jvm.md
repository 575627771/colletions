## _jvm_

- ##### 主要是为了屏蔽底层操作系统操作命令的不同而做的兼容平台，同时完成java代码的加载，分配内存，运行，运行时垃圾回收等操作；
- 如何学习？？？
- 1.8之前的jvm 以及 1.8 基于HotSpot

- ## 1.8之前

- 程序计数器
    - 线程私有；
    - 程序计数器是当前线程所执行的字节码的行号指示器，也就是说字节码解释器是通过改变程序计数器的值来选择下一条需要执行的字节码指令；如线程切换、判断、循环、跳转、异常处理等；
    - 如果线程执行的是Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，如果是Native方法，则为空（Undefined）
    - 此内存区域是唯一一个不会出现OOM的区域；
    
- 虚拟机栈
    - 线程私有，生命周期与线程相同；
    - 描述了Java方法执行的内存模型：
    
          每个方法在执行的同时都会创建一个栈帧用于存储`局部变量表`、`操作数栈`、`动态链接`、`方法出口`等信息，每一个方法从调用到执行完成，就对应着一个栈帧在虚拟机栈中的入栈到出栈；
    - 局部变量表存放了编译期可知的各种基本数据类型、对象引用（不等同于对象本身，是一个引用指针，或者句柄）和returnAddress
    - 虚拟机栈可能会出现两个异常：
        - StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度（这个深度可以动态扩展，也可以是固定的）；
        - OutOfMemoryError：如果虚拟机栈的深度可以动态扩展，那么在无法申请到足够内存是就会抛出此异常；
        
- 本地方法栈
    - 与虚拟机栈类似，只是虚拟机栈是为执行Java方法服务，而本地方法栈是为虚拟机调用本地方法服务；
    - HotSpot中把虚拟机栈和本地方法栈合并在一起；
    - 也会出现 StackOverflowError 和 OutOfMemoryError 两个异常；
    
- 堆(heap)
    - 垃圾收集器管理的主要区域；
    - 所有线程共享的内存区域，主要用于存放对象实例；（由于JIT编译器的发展以及逃逸分析技术逐渐成熟，也不是那么绝对了）
    - `从内存回收角度`，由于收集器基本采用分代收集算法，堆还可以分为新生代、老年代；
        - 新生代又可分为：Eden区、From Survivor 和 To Survivor ;
    - `从内存分配角度`，线程共享的堆可能划分出多个线程私有的分配缓冲区；
    - 堆可以处于物理上不连续的内存空间，逻辑上连续即可，在实现上可以是固定的也可以是可扩展的，当前主流的虚拟机都是可扩展的（通过-Xms和-Xmx控制）
    - 如果在堆中没有内存完成实例分配，并且堆也无法再扩展，将抛出 OutOfMemoryError 异常；
    
- 方法区
    - 所有线程共享的内存区域，主要用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；
    - HotSpot 把GC分代扩展至方法区，--永久代；
    - 当方法区无法满足内存分配时，抛出OutOfMemoryError异常。
    
- 运行时常量池
    - 方法区的一部分，用于存放编译期生成的各种字面量和符号引用，在类加载后存在进运行时常量池；
    - 相对于Class文件常量池，运行时常量池支持动态扩展；
    - 同样再无法申请到内存时会抛出OutOfMemoryError异常。
    
- 直接内存    
    - 不是虚拟机运行时数据区的一部分，也可能出现OOM异常；
    
## HotSpot虚拟机对象

- ####对象的创建

    当虚拟机遇到New指令时，首先检查指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化；如果没有则先执行类的加载过程；
  
    在加载检查通过后，虚拟机将`为新生对象分配内存`，对象所需的内存大小在类加载完成后便可完全确认，为对象分配内存的任务相当于把一块确定大小的内存从堆中划分出来；
    - 指针碰撞：堆中内存是规整的，所有用过的内存都放在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，这种分配方式称为“指针碰撞”；
    - 空闲列表：如果堆中的内存不是规整的，已使用和未使用的内存相互交错，虚拟机就必须维护一个列表，记录那些内存时可用的，在分配内存的时候从列表中找到一块足够大的空间分给对象，并更新列表，这种方式称为“空闲列表”；
    具体是什么使用什么分配方式由堆是否规整决定，而堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定，在使用Serial、ParNew等带有Compact过程的收集器时，系统采用指针碰撞方式，在使用CMS时，通常采用空闲列表；
    
    除了划分可用空间之为，还需要考虑在划分可用空间时的线程安全问题，两种方案：
    - 分配内存空间的动作进行同步处理————实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；
    - 把内存分配的动作按照线程划分在不同的空间进行，即每一个线程在堆中预先分配一小块内存，称为`本地线程分配缓冲`（TLAB,Thread Local Allocation Buffer），先在线程的TLAB上分配，只有TLAB使用完并重新分配新的TLAB时，才需要同步锁定；

    是否使用TLAB可以通过-XX:+/-UseTLAB参数来设定；
    
    内存分配完成后，还需要将分配到的内存空间都`初始化为零值`（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行，保证对象的实例字段在Java代码中可以不赋初始值就可以直接使用；
    
    接下来虚拟机要对对象进行必要的设置，如这个对象是那个类的实例，如何才能找到这个类的元数据信息、对象的哈希码、GC分代年龄、偏向锁等等，从虚拟机角度一个新对象已经产生，但是Java程序的视角，还没有执行<init>方法，没有按照程序员的意愿进行初始化。
    
- ####对象的内存布局
    - 对象头（Header）
        
        对象头分为两部分：
        - 第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等，在32位和64位虚拟机中分别为32bit和64bit（Mark Word），其实对象需要存储的运行时数据很多，已经超过了32位或者64位，
        为了提高虚拟机的空间效率，Mark Word被设计成了一个非固定的数据结构以便在极小的空间内存存储尽量多的信息，它会根据对象的状态复用自己的存储空间；
        - 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是那个类的实例。如果是数据，还需要有一块空间用于记录数组的长度；
    - 实例数据（Instance Data）
    
        - 对象真正存储的有效信息，也就是代码中定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。
        - 这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中的定义顺序的影响；
    
              HotSpot虚拟机默认的分配策略为：longs/doubles、ints、shorts/chars、bytes/booleans、oops，可以看出相同宽度的字段总是被分配在一起。
              在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。
              如果CompactFields参数为True，那么子类之中较窄的变量也可能会插入父类变量的空隙之中；
    - 对齐填充（Padding）
        - 对齐填充并不是必然存在的，起着占位符的作用；
        
- ####对象的访问定位
    
    创建对象是为了使用对象，Java程序需要通过栈上的 reference 数据来操作堆上的具体对象。
    - 主流的访问方式有两种：
            
        1. 如果使用句柄的话，Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
        2. 如果使用直接指针，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址；
    
        两种对象访问方式各有优势，句柄来访问的好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而使用直接指针访问的最大好处就是速度快，节省一次指针定位的时间开销；对于HotSpot而言使用的是直接指针的方式访问对象；

## 垃圾收集器和内存分配策略

   - 那些对象需要回收
      - 引用计数法
          
            引用计数法是给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1，任何时刻计数器为0的对象就是不可能在被使用的；
            
      引用计数法实现简单，判定效率高，大部分情况下是一个不错的算法，但是在解决循环引用时就有问题了；
      
      - 可达性分析
            
            通过 GC Roots 向下搜索，当一个对象到 GC Roots 没有任何引用链相连时，证明此对象不可用；
        GC Roots 包括：
           - 虚拟机栈（栈帧中的本地变量表）中的引用对象；
           - 方法区中的类静态属性引用的对象；
           - 方法区中的常量引用的对象；
           - 本地方法栈中JNI（即一般说的Native方法）引用的对象
           
      - 引用
        - 强引用
            
              指在代码中普遍存在的，类似“Object obj=new Object()”这类引用。只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象；
        - 软引用
           
              用来描述一些还有用但并非必须的对象。系统在将要发生内存溢出异常之前回收，如果回收后还没有足够的内存，就抛出内存溢出异常；
              可以通过 SoftReference 类来实现软引用
        - 弱引用
        
              用来描述非必需对象，比软引用强度更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
              可以使用 WeakReference 类来实现弱引用；
        - 虚引用
        
              也称为幽灵引用或者幻影引用，是最弱的一种引用关系。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知；
              可以使用 PhantomReference 类来实现虚引用；
      
      在可达性分析后不可达的对象也并非是`非被回收不可`，要被真正的回收`至少`需要经历两次标记过程；而第一次标记发生在可达性分析中，没有对象可达时被标记一次，
      然后进行一次筛选，看是否有必要执行finalize()方法，对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机执行过（最多只能被虚拟机执行一次）————视为“没有必要执行”；
      如果对象判定有必要执行finalize()方法，那么会把这个对象放进一个叫做FQueue的队列，虚拟机会自动建立一个低优先级的finalizer线程去触发finalize()方法，不会等待其运行结束，
      以避免执行缓慢，或者出现死循环，导致整个F-Queue队列的其他对象永远处于等待，致使整个垃圾回收系统崩溃，GC会对F-Queue中的对象进行一次小规模的二次标记，只有在执行finalize()
      方法时重新与引用链上的任何成员建立关联，在二次标记时将会被从F-Queue中移除，否则就真的被回收了。
      
      - 回收方法区
        
        方法区可以对废弃常量和无用类进行回收；回收废弃常量与回收Java堆中的对象非常类似，没有任何string对象引用常量池中的“abc”常量，也没有其他地方引用这个字面常量，
        这时发生垃圾回收，而且有必要的话，“abc”常量就会被系统回收；
        
        常量池中其他类、方法、字段的符号引用也于此类似；只是条件比较苛刻：
            - 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
            - 加载该类的ClassLoader已经被回收
            - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
   
   - 垃圾回收算法
      - 标记-清除算法
        
            标记-清除（Mark-Sweep）算法，分为两个阶段：
            1. 标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象；
            2. 清除
      不足：一个是效率问题，标记和清楚两个过程的效率都不高；另一个是空间问题，标记清楚之后会产生大量的不连续内存碎片，导致大对象分配时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作；
         
      - 复制算法
      
            为了解决效率问题，一种复制（Copying）收集算法出现，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块使用完了之后，就将还存活的对象复制到另外一块上面，
            然后把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时不用考虑内存碎片问题，只要移动堆顶指针，按照顺序分配内存即可，
      HotSpot中是将内存分为一块较大的Eden区和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor，回收时，将Eden和Survivor中存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才的Survivor空间
      HotSpot虚拟机Eden和Survivor空间默认比例时`8:1`,也就是每次新生代中可用内存空间为这个新生代容量的90%，只有10%的内存会被浪费，当然可能会存在存活对象需要的内存大于这个10%的时候，这时老年代提供了分配担保；
      这些对象将会直接通过分配担保机制进入老年代；
      
      - 标记-整理算法
      
            复制收集算法在对象存活率比较高时就要进行比较多的复制操作，效率将会变低。更关键的时，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代一般不能直接选用这种算法；
            根据老年代的特点，有人提出了标记整理算法（Mark-Compact），标记过程仍然与标记-清楚算法一样，但是后续步骤不是直接堆可回收对象进行清理，而是让所有的存货对象都向一端移动，然后直接清理掉端边界以外的内存；
      
      - 分代收集算法
            
            当前商业虚拟机的垃圾收集都是采用分代收集（Generational Collection）算法；把堆分为新生代和老年代，根据各个年代的特点采用适当的收集算法；
            新生代中，每次垃圾收集时都发现有大批量的对象死去，只有少量存活，因此选用复制算法，只需要付出少量存活对象的复制成本，就可完成收集。
            老年代对象存活率高、没有额外空间对它进行分配担保，就必须使用`标记-清理`或者`标记-整理`算法来进行回收；
      
   - HotSpot的算法实现
   
      - 枚举根节点
            
            从可达性分析中GC Roots 节点找到引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或者类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在有很多应用仅仅方法区就有数百兆，
            如果要逐个检查里面的引用，那么必然会消耗很多时间；
            
            另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里的一致性是指在分析期间这个执行系统看起来就像被冻结在某个时间节点上，不可以出现分析过程中对象引用关系还在不断变化的情况，
            该节点不满足的话分析结果准确性就无法得到保障。这点是导致GC进行时必须停顿所有的Java执行线程的其中一个重要原因，即使是在号称不会发生停顿的CMS收集器中，枚举根节点也是必须要停顿的；
            
            当前主流的虚拟机都是准确式GC,所以当执行系统停顿下来后，并不需要一个不漏的检查完所有的执行上下文和全局的引用位置，在HotSpot虚拟机中是使用了一个OopMap的数据结构来达到这个目的的，`在类加载完成的时候，HotSpot就把对象内什么偏移量上是
            什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中那些位置是引用`，这样在GC扫描的时候就可以直接得知这些信息了。
            
      - 安全点
      
            在OopMap的协助下，HotSpot可以快速准确的完成GC Roots 枚举，但是可能导致OopMap内容变化的指令非常多，HotSpot中是使用安全点（Safepoint）来开始GC操作的；在安全点所有的业务线程都会停止，同时也会记录OopMap；
            安全点的选定：是否具有让程序长时间执行的特征为标准；
            因为每一条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长的执行，“长时间执行”的明显特征就是指令序列复用，如**_方法调用，循环跳转。异常跳转_**，所以具有这些功能的指令才会产生Safepoint；
            
      对于Safepoint，另一个需要考虑的问题是如果在GC发生时让所有的线程都跑到安全点上再停顿下来。
      1. 抢先式中断：抢先式中断不需要线程执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点，就恢复线程，让它跑到安全点上；
      2. 主动式中断：GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标识，各线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方；
      
      - 安全区域
            
            使用安全点似乎已经完美的解决了如何进入GC的问题，实际上安全点只是解决了程序执行时，再不太长的时间内就会遇到可进入GC的安全点，但是程序`不执行`的时候没法满足————这里的不执行是指没有分配cpu时间，比如线程处于sleep或者blocked状态；
            这时候线程无法响应JVM的中断请求，没法到安全点挂起，这个时候就需要安全区域来解决；
            安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任意位置都可以开始GC；
            在线程执行到安全区域中的代码时，首先标识自己已经进入安全区域，当JVM发起GC时就不用去管标识自己为安全区域的线程了，在线程要离开安全区域时，需要检查系统是否已经完成了GC Roots枚举，如果完成，那就继续执行，否则就必须等待直到收到可以安全离开的信号；
   
   - 垃圾收集器
      - 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上；
      - 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程任然处于等待状态。
      
      - Serial收集器
        
        单线程收集器，不仅仅是只会使用一个CPU或者一个收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂定其他所有的工作线程，直到收集结束；
   
      - ParNew收集器
      
            Serial收集器的多线程版本，许多虚拟机server模式下的默认新生代收集器；
            可以用-XX:ParallelGCThreads指定线程数；
            用-XX:+UseParNewGC指定使用ParNew收集器
            用-XX:+UseConcMarkSweepGC （cms收集器）后的默认收集器
            
      - Parallel Scavenge收集器
      
            首先是复制算法的收集器，又是并行的多线程收集器，同时关注达到一个可控的吞吐量；
            
            吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）
            
            用-XX:MaxGCPauseMillis控制最大垃圾收集停顿时间，大于0
            
            用-XX:GCTimeRatio直接设置吞吐量大小，值是1~99的整数
            
            用-XX:+UseAdaptiveSizePolicy 这是一个开关参数，开启后就不需要设置新生代大小、Eden和Survivovr区的比例、晋升老年代对象的年龄等细节参数；虚拟机会根据当前系统的运行情况，动态的调整，以达到最大吞吐量
            
         停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，
         而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务；
      
      - Serial Old收集器
            
            老年代单线程收集器，使用的`标记-整理`算法；
            主要是与Parallel Scavenge搭配使用或者作为CMS收集器的后备预案
            
      - Parallel Old收集器
      
            是Parallel Scavenge收集器的老年代版本，使用多线程和`标记-整理`算法
            
      - CMS（Concurrent Mark Sweep）收集器
      
            是一种以获取最短回收停顿时间为目标的收集器，基于`标记-清除`算法，主要包括四个步骤：
            1. 初始标记：仅仅是标记一下GC Roots能直接关联到的对象，速度很快，会导致“Stop The World”；
            2. 并发标记：就是进行GC RootsTracing的过程，与用户线程一起工作；
            3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，会导致“Stop The World”，同时比初始标记时间长，但是远比并发标记时间短；
            4. 并发清除：与用户线程一起工作；
      
      由于整个中耗时最长的并发标记和并发清除都是与用户线程一起工作，因此总体上来说CMS收集器的内存回收过程是与用户线程一起并发执行的；
      
      缺点：
        
        1. 对CPU资源非常敏感，在并发标记和并发清除的时候会使用（CPU数量+3）/4 的CPU资源;
        
        2. 无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另外一次Full GC的产生。因为在垃圾收集阶段用户线程还在不断运行，因此需要为用户线程预留内存空间，`JDK1.5中老年代使用68%的空间后就会被激活`
        如果老年代增长不是很快，可以使用 -XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，在JDK1.6中已经将这一阈值提升至92%，要是在CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”
        这时虚拟机将启动后备预案：临时启动Serial Old收集器来重新对老年代进行垃圾收集，这样停顿时间就很长了，所以-XX:CM SInitiatingOccupancyFraction 参数不能设置太高；
        
        3. CMS时一款基于`标记-清除`算法的收集器，会产生大量的内存碎片，导致没有足够大的连续内存分配给大对象，不得不提前触发一次Full GC，为了解决这个问题，CMS提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的）
        用于在CMS收集器顶不住要进行Full GC时开启内存碎片合并整理过程，内存整理时无法并发执行的。同时提过了-XX:CMSFullGCsBeforeCompaction参数来设置多少次不压缩的Full GC后进行一次带压缩的Full GC；
        
      - G1收集器
      
            是一款面向服务端应用的垃圾收集器
            `并行与并发`：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来压缩Stop-The-World停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行；
            `分代收集`：与其他收集器一样，分代概念在G1中得到了保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是它能采用不同的方式区处理新创建的对象和已经存活一段时间、熬过多次GC的旧对象以获取更好的收集效果；
            `空间整合`：与CMS“标记-清除”算法不同，G1从整体来看时基于“标记-整理”算法实现的，从局部来看是基于复制算法来实现的，意味着G1收集器不会产生内存碎片。
            `可预测的停顿`：G1相对于CMS的有一大优势，降低停顿时间时G1 和CMS共同关注的问题，但是G1除了追求低停顿外，还能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒；
            
      在使用G1收集器时Java堆内存布局与其他收集器的差别很大，G1是将Java堆分为多个大小相等的独立区域（region），使得老年代和新生代不在物理隔离；
      
      之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集，G1会跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。
      保证了G1收集器在有限的时间内可以获取尽可能高的收集效率；
      
      在G1中，Region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，虚拟机都是通过使用Remembered Set来避免全堆扫描的。G1中的每一个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，
      会产生一个Write Barrier暂时中断写操作，检查Reference引用对象是否处于同一个Region中（分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中
      当内存回收时，GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会遗漏。
      
      G1收集器的运作大致分为四个步骤：
        - 初始标记：仅仅是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这个阶段需要`停顿线程`，但是时间很短；
        - 并发标记：时从GC Roots开始对堆中的对象进行可达性分析，找出存活的对象，这个阶段耗时比较长，但是可与用户线程并发执行。
        - 最终标记：为了修正在并发标记期间因用户程序继续执行而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象的变化记录在线程的Remembered Set Log里，最终标记阶段需要把数据合并到Remembered Set中，这个阶段需要`停止用户线程`，但是可`并行`执行。
        - 筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户的期望GC停顿时间来制定回收计划，需要`停顿线程`；
   
   - 内存分配与回收策略
     
         对象的内存分配，往大方向上讲，就是在堆上分配（可能存在经过JIT编译后被拆撒为标量类型并间接的栈上分配），对象主要分配在新生代的Eden区上，
         如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况可能直接接入老年代，取决于垃圾收集器和内存相关参数；
         
     - 对象优先分配在Eden区
     
     - 大对象直接分配至老年代
     
     - 长期存活对象将进入老年代（默认年龄为15）
     
     - 动态对象年龄判断：如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象可以直接进入老年代；
     
     - 空间分配担保：在发生Minor GC之前，虚拟机会检查老年代的连续空间内存是否大于新生代所有对象总空间，如果大于，那么进行Minor GC是安全的，
     如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，那么继续检查老年代最大可用连续空间是否大于历次晋升到
     老年代对象的平均大小，如果大于，将尝试进行Minor GC，如果小于或者HandlePromotionFailure设置不允许冒险，则这时进行一次Full GC。
   
## 虚拟机性能监控与故障处理工具





## 虚拟机执行子系统

- 无关性的基石
    虚拟机和字节码存储格式
    
- Class文件类型
    
    Class文件是一组以8位字节为单位的二进制流，采用一种类似于C语言结构的伪结构来存储数据