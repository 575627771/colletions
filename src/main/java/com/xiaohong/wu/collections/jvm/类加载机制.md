##虚拟机类加载机制

- 类初始化的时机
    
    - 虚拟机规范定义了有且仅有五种情况需要立即初始化类
    
        1. 有new、getStatic、putStatic、invokeStatic这三种指令的时候需要立即初始化
        2. 被反射调用的时候
        3. 初始化的类有父类，且父类没有初始化的时候。需要优先初始化父类
        4. 虚拟机启动的时候需要指定一个要执行的主类，虚拟机会优先初始化
        5. 动态代理解析结果Ref_getStatic、。。。的方法句柄，并且这个方法句柄所对应的类没有初始化
    
    也就是说只有主动引用的时候才会触发初始化
    
    - 类的加载过程
    
        主要分为 加载、验证、准备、解析、初始化、使用、卸载 七个阶段，且加载、验证、准备、初始化、卸载这五个的开始顺序是确定的
        
        1. 加载
            
            虚拟机主要完成三件事：
            
               1. 通过一个类的全限定名来获取定义此类的二进制字节流
               2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
               3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口
               
            但是虚拟机只是说了通过一个全限定名来获取二进制字节流文件，没有规定以什么方式获取，在哪里获取？因此就有了很多发挥的空间，如：
             
               从zip包中读取，如jar、ear、war格式的包中获取。
               从网络中获取，这种场景最经典的应用就是applet。
               运行时计算生成，这种场景使用得最多的就是动态代理技术。
               有其他文件生成，典型场景就是jsp。
               从数据库读取，这种场景根据配置读取对应的解析文件。
            
            对于数组而言，数组类本身不通过类加载器创建，而是由Java虚拟机直接创建。数据类的基本类型是由类加载器去创建的。
            
            加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个class类对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口
            
        2. 验证
        
            验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
            
            验证阶段的工作量在虚拟机的类加载子系统中站了相当大一部分，其主要进行了四个方面的验证：文件格式验证、元数据验证、字节码验证、符号引用验证。
            
               1. 文件格式验证：是直接基于二进制字节流进行验证的，只有通过这个阶段后，字节流才会进入方法区进行存储，所以后面三个阶段的验证都是基于方法区的存储结构进行的。
               2. 元数据验证：对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。
               3. 字节码验证：
               4. 符号引用验证：
        
        3. 准备
        
            准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些类变量所使用的内存豆浆在方法区中进行分配；这个阶段只会为类变量（被static修饰）分配内存，同时初始值为数据类型的零值。
            如果是被 static final 修饰，才会被赋予真实值。
            
        4. 解析
        
            主要是将常量池中的符号引用替换为直接引用；
            
               符号引用：和内存没有关系的，能无歧义的定位目标的字面量。
               直接引用：可以是直接指向目标的指针、相对偏移量活是一个能间接定位到目标的句柄。
               
            